<template>
  <table
    width="100%"
    cellspacing="0"
    cellpadding="0"
    class="ht-date-table"
    @click="onClick"
    @mousemove="onMouseMove"
  >
    <tbody>
      <tr>
        <th v-for="(item, index) in WEEKS" :key="index">{{ item }}</th>
      </tr>
      <tr v-for="(row, rowIndex) in rows" :key="rowIndex" class="row">
        <td
          v-for="(cell, cellIndex) in row"
          :key="`${rowIndex}-${cellIndex}`"
          class="cell"
        >
          {{ cell?.text }}
        </td>
      </tr>
    </tbody>
  </table>
</template>
<script lang="ts">
import { defineComponent, computed, ref } from "vue";
import dayjs from "dayjs";
import type { PropType } from "vue";
import type { Dayjs } from "dayjs";

export default defineComponent({
  props: {
    date: {
      type: Object as PropType<Dayjs>,
    },
    minDate: {
      type: Object as PropType<Dayjs>,
    },
    maxDate: {
      type: Object as PropType<Dayjs>,
    },
    parsedValue: {
      type: [Object, Array] as PropType<Dayjs | Dayjs[]>,
    },
    selectionMode: {
      type: String,
      default: "day",
    },
    //   showWeekNumber: {
    //     type: Boolean,
    //     default: false,
    //   },
    disabledDate: {
      type: Function,
    },
    rangeState: {
      type: Object,
      default: () => ({
        endDate: null,
        selecting: false,
      }),
    },
  },

  setup(props, { emit }) {
    const lang = ref("zh-cn");

    const firstDayOfWeek = (props.date as any).$locale().weekStart || 7;

    const WEEKS_CONSTANT = ["日", "一", "二", "三", "四", "五", "六"];

    const WEEKS = computed(() =>
      WEEKS_CONSTANT?.concat(WEEKS_CONSTANT).slice(
        firstDayOfWeek,
        firstDayOfWeek + 7
      )
    );

    const offsetDay = computed(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });

    const tableRows = ref([[], [], [], [], [], []]);

    const startDate = computed(() => {
      const startDayOfMonth = props?.date?.startOf("month");
      return startDayOfMonth?.subtract(startDayOfMonth.day() || 7, "day");
    });

    const cellMatchesDate = (cell: any, date: any) => {
      if (!date) return false;
      return dayjs(date)
        .locale(lang.value)
        .isSame(props.date?.date(Number(cell.text)), "day");
    };

    const isCurrent = (cell: any): boolean => {
      return (
        props.selectionMode === "day" &&
        (cell.type === "normal" || cell.type === "today") &&
        cellMatchesDate(cell, props.parsedValue)
      );
    };

    const rows = computed(() => {
      const startOfMonth = props?.date?.startOf("month");
      const startOfMonthDay = startOfMonth?.day() || 7; // day of first day
      const dateCountOfMonth = startOfMonth?.daysInMonth() || 30;
      const dateCountOfLastMonth =
        startOfMonth?.subtract(1, "month")?.daysInMonth() || 30;
      const offset = offsetDay.value;
      const newRows = tableRows.value;
      let count = 1;

      const selectedDate: Dayjs[] = [];

      const calNow = dayjs().locale(lang.value).startOf("day");

      for (let i = 0; i < 6; i++) {
        const row = newRows[i];

        for (let j = 0; j < 7; j++) {
          let cell: any = row[j];
          if (!cell) {
            cell = {
              row: i,
              column: j,
              type: "normal",
              inRange: false,
              start: false,
              end: false,
            };
          }
          const index = i * 7 + j;
          const calTime = startDate.value?.add(index - offset, "day");
          cell.dayjs = calTime;
          cell.date = calTime?.toDate();
          cell.timestamp = calTime?.valueOf();
          cell.type = "normal";

          const calEndDate =
            props.rangeState.endDate ||
            props.maxDate ||
            (props.rangeState.selecting && props.minDate);

          cell.inRange =
            (props.minDate &&
              calTime?.isSameOrAfter(props.minDate, "day") &&
              calEndDate &&
              calTime?.isSameOrBefore(calEndDate, "day")) ||
            (props.minDate &&
              calTime?.isSameOrBefore(props.minDate, "day") &&
              calEndDate &&
              calTime?.isSameOrAfter(calEndDate, "day"));

          if (props.minDate?.isSameOrAfter(calEndDate)) {
            cell.start = calEndDate && calTime?.isSame(calEndDate, "day");
            cell.end = props.minDate && calTime?.isSame(props.minDate, "day");
          } else {
            cell.start = props.minDate && calTime?.isSame(props.minDate, "day");
            cell.end = calEndDate && calTime?.isSame(calEndDate, "day");
          }

          const isToday = calTime?.isSame(calNow, "day");

          if (isToday) {
            cell.type = "today";
          }

          if (i >= 0 && i <= 1) {
            const numberOfDaysFromPreviousMonth =
              startOfMonthDay + offset < 0
                ? 7 + startOfMonthDay + offset
                : startOfMonthDay + offset;
            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
              cell.text = count++;
            } else {
              cell.text =
                dateCountOfLastMonth -
                (numberOfDaysFromPreviousMonth - (j % 7)) +
                1 +
                i * 7;
              cell.type = "prev-month";
            }
          } else if (count <= dateCountOfMonth) {
            cell.text = count++;
          } else {
            cell.text = count++ - dateCountOfMonth;
            cell.type = "next-month";
          }

          const cellDate = calTime?.toDate();
          cell.selected = selectedDate.find(
            (_) => _.valueOf() === calTime?.valueOf()
          );
          cell.isSelected = !!cell.selected;
          cell.isCurrent = isCurrent(cell);
          cell.disabled = props.disabledDate && props.disabledDate(cellDate);
          row[j] = cell;
        }
      }
      return newRows;
    });
    //   // data
    //   const lastRow = ref(null);
    //   const lastColumn = ref(null);

    //

    //

    //

    //

    //

    //

    //   const getDateOfCell = (row, column) => {
    //     const offsetFromStart =
    //       row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
    //     return startDate.value.add(offsetFromStart, "day");
    //   };

    //   const handleMouseMove = (event) => {
    //     if (!props.rangeState.selecting) return;

    //     let target = event.target;
    //     if (target.tagName === "SPAN") {
    //       target = target.parentNode.parentNode;
    //     }
    //     if (target.tagName === "DIV") {
    //       target = target.parentNode;
    //     }
    //     if (target.tagName !== "TD") return;

    //     const row = target.parentNode.rowIndex - 1;
    //     const column = target.cellIndex;

    //     // can not select disabled date
    //     if (rows.value[row][column].disabled) return;

    //     // only update rangeState when mouse moves to a new cell
    //     // this avoids frequent Date object creation and improves performance
    //     if (row !== lastRow.value || column !== lastColumn.value) {
    //       lastRow.value = row;
    //       lastColumn.value = column;
    //       ctx.emit("changerange", {
    //         selecting: true,
    //         endDate: getDateOfCell(row, column),
    //       });
    //     }
    //   };

    //   const handleClick = (event) => {
    //     let target = event.target;

    //     while (target) {
    //       if (target.tagName === "TD") {
    //         break;
    //       }
    //       target = target.parentNode;
    //     }

    //     if (!target || target.tagName !== "TD") return;

    //     const row = target.parentNode.rowIndex - 1;
    //     const column = target.cellIndex;
    //     const cell = rows.value[row][column];

    //     if (cell.disabled || cell.type === "week") return;

    //     const newDate = getDateOfCell(row, column);

    //     if (props.selectionMode === "range") {
    //       if (!props.rangeState.selecting) {
    //         ctx.emit("pick", { minDate: newDate, maxDate: null });
    //         ctx.emit("select", true);
    //       } else {
    //         if (newDate >= props.minDate) {
    //           ctx.emit("pick", { minDate: props.minDate, maxDate: newDate });
    //         } else {
    //           ctx.emit("pick", { minDate: newDate, maxDate: props.minDate });
    //         }
    //         ctx.emit("select", false);
    //       }
    //     } else if (props.selectionMode === "day") {
    //       ctx.emit("pick", newDate);
    //     } else if (props.selectionMode === "week") {
    //       const weekNumber = newDate.week();
    //       const value = `${newDate.year()}w${weekNumber}`;
    //       ctx.emit("pick", {
    //         year: newDate.year(),
    //         week: weekNumber,
    //         value,
    //         date: newDate.startOf("week"),
    //       });
    //     } else if (props.selectionMode === "dates") {
    //       const newValue = cell.selected
    //         ? coerceTruthyValueToArray(props.parsedValue).filter(
    //             (_) => _.valueOf() !== newDate.valueOf()
    //           )
    //         : coerceTruthyValueToArray(props.parsedValue).concat([newDate]);
    //       ctx.emit("pick", newValue);
    //     }
    //   };

    //   const isWeekActive = (cell) => {
    //     if (props.selectionMode !== "week") return false;
    //     let newDate = props.date.startOf("day");

    //     if (cell.type === "prev-month") {
    //       newDate = newDate.subtract(1, "month");
    //     }

    //     if (cell.type === "next-month") {
    //       newDate = newDate.add(1, "month");
    //     }

    //     newDate = newDate.date(parseInt(cell.text, 10));

    //     if (props.parsedValue && !Array.isArray(props.parsedValue)) {
    //       const dayOffset =
    //         ((props.parsedValue.day() - firstDayOfWeek + 7) % 7) - 1;
    //       const weekDate = props.parsedValue.subtract(dayOffset, "day");
    //       return weekDate.isSame(newDate, "day");
    //     }
    //     return false;
    //   };

    return {
      WEEKS,
      tableRows,
      startDate,
      rows,
      // handleMouseMove,
      // t,
      // isWeekActive,
      // handleClick,
    };
  },
});
</script>
